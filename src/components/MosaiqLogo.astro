---
interface Props {}
const props = Astro.props;
const colors = {
    s: '#2384ca',
    i: '#21286c',
    p: '#482362',
    m: '#932e76',
    k: '#d31757',
    t: 'transparent',
};

const logo = `ppptiiiitsss
ppptiiiitsss
ppptiiiitsss
tttttiiitttt
mmmmtttttiii
mmmmtpptiiii
mmmmtpptiiii
mmmtttttiiii
ttttmmmttttt
kkktmmmmtppp
kkktmmmmtppp
kkktmmmmtppp`;
---

<div class="logo-container">
    <div class="mosaiq-logo">
        {
            logo.split('\n').map((row, y) => (
                <div class="row">
                    {row.split('').map((char, x) => {
                        const color = colors[char as keyof typeof colors] || colors.t;
                        return (
                            <div
                                data-x={x}
                                data-y={y}
                                class={color === "transparent" ? "cell-spacer" : "cell"}
                                style={`background-color: ${color};`}
                            />
                        );
                    })}
                </div>
            ))
        }
    </div>
</div>
<script>
    import { gsap } from 'gsap';

    import { ScrollTrigger } from 'gsap/ScrollTrigger';
    import { ScrollSmoother } from 'gsap/ScrollSmoother';

    gsap.registerPlugin(ScrollTrigger, ScrollSmoother);
    const content = document.querySelector('.mosaiq-logo');
    const container = document.querySelector('.logo-container');
    if (!content) throw new Error('No content element found');

    const cells = content.querySelectorAll('.cell');

    function calculatePath(cell: Element) {
        const projectCards = document.querySelectorAll('.project-card');

        const cellRect = cell.getBoundingClientRect();
        const cellCenter = {
            x: cellRect.left + cellRect.width / 2,
            y: cellRect.top + cellRect.height / 2
        };
        
        const cellPaths: Array<{ start: { x: number; y: number }; end: { x: number; y: number } }> = [];
        
        projectCards.forEach((card) => {
            const cardRect = card.getBoundingClientRect();
            const cardCenter = {
                x: cardRect.left + cardRect.width / 2,
                y: cardRect.top + cardRect.height / 2
            };

            // calculate normal-distributed random offset for path
            const u1 = Math.random();
            const u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            const z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2);
            const offsetX = z0 * 50;
            const offsetY = z1 * 50;

            const offsetCardCenter = {
                x: cardCenter.x + offsetX,
                y: cardCenter.y + offsetY
            };
            
            cellPaths.push({
                start: cellCenter,
                end: offsetCardCenter,
            });
        });

        return cellPaths;
    }

    function calculateTimeline(cell: Element, paths: Array<{ start: { x: number; y: number }; end: { x: number; y: number } }>) {
        const duration = 0.8 + Math.random() * 0.4;
        const rotation = Math.random() * 180 - 90;

        console.log(paths);

        // Create a timeline for the animation
        const tl = gsap.timeline({ paused: true});
        
        if (!paths) return tl;

        for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            const logoRect = content!.getBoundingClientRect();
            
            // Convert screen coordinates to logo coordinates
            const startX = path.start.x - logoRect.left;
            const startY = path.start.y - logoRect.top;
            const endX = path.end.x - logoRect.left;
            const endY = path.end.y - logoRect.top;

            let distance: number;
            if (i === 0) {
                distance = Math.hypot(endX - startX, endY - startY);
            } else {
                const prevPath = paths[i - 1];
                const prevEndX = prevPath.end.x - logoRect.left;
                const prevEndY = prevPath.end.y - logoRect.top;
                distance = Math.hypot(endX - prevEndX, endY - prevEndY);
            }
            
            tl.to(cell, {
                x: endX - startX,
                y: endY - startY,
                // outline: '4px solid var(--color-background)',
                rotation,
                duration: distance * duration, // Scale duration based on distance
                ease: 'linear'
            });
        }

        return tl;
    }

    function createScrollTrigger(cell: Element, tl: gsap.core.Timeline) {
        const delay = 100 + Math.random() * 100;
        ScrollTrigger.create({
            trigger: document.body,
            start: `${delay}px top`,
            end: `bottom bottom`,
            // end: `bottom+=${delay}px bottom`,
            scrub: 1,
            onUpdate: (self) => {
                tl.progress(self.progress);
            }
        });
    }

    // create the animation after a delay to ensure all elements are rendered
    setTimeout(() => {
        for (const cell of cells) {
            const paths = calculatePath(cell);
            const tl = calculateTimeline(cell, paths);
            createScrollTrigger(cell, tl);
        }
        ScrollTrigger.refresh();
    }, 1000);

    gsap.to(container, {
        rotateX: '20deg',
        rotateY: '-20deg',
        ease: 'power2.out',
    });
    
    gsap.to(content, {
        rotateZ: '15deg',
        ease: 'power2.out',
    });

    ScrollTrigger.create({
        trigger: document.body,
        start: "100px top",
        end: "500px top",
        scrub: 1,
        onUpdate: (self) => {
            const progress = self.progress;
            gsap.to(container, {
                rotateX: `${20 * (1 - progress)}deg`,
                rotateY: `${-20 * (1 - progress)}deg`,
                duration: 0.1,
                ease: 'power2.out',
            });
            gsap.to(content, {
                rotateZ: `${15 * (1 - progress)}deg`,
                duration: 0.1,
                ease: 'power2.out',
            });
        }
    });

    cells.forEach((cell, index) => {
        const x = cell.getAttribute('data-x');
        const y = cell.getAttribute('data-y');

        if (x !== null && y !== null) {
            const tl = gsap.timeline({
                repeat: -1,
                delay: (parseInt(x) + parseInt(y)) * 0.15
            });

            tl.fromTo(cell,
                {
scale: 1.05,
                },
                {
                    scale: 0.8,
                    duration: 1,
                    ease: 'power1.inOut',
                }
            );

            tl.to(cell,
                {
                    scale: 1.05,
                    duration: 1,
                    ease: 'power1.inOut',
                }
            );

            tl.to(cell,
                {
                    scale: 1.05,
                    duration: 3,
                }
            );
        }

        gsap.fromTo(
            cell,
            { opacity: 0, y: 50 },
            {
                opacity: 1,
                y: 0,
                delay: index * 0.01,
                duration: 0.5,
                ease: 'power2.out',
            }
        );
    });
</script>
<style>
    .mosaiq-logo {
        display: flex;
        gap: 0;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }
    .row {
        display: flex;
        gap: 0;
    }
    .cell, .cell-spacer {
        width: 3.5vw;
        height: 3.5vw;
        z-index: 2;
    }
</style>
