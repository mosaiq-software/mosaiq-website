---
interface Props {}
const props = Astro.props;
const colors = {
    s: '#2384ca',
    i: '#21286c',
    p: '#482362',
    m: '#932e76',
    k: '#d31757',
    t: 'transparent',
};

const logo = `ppptiiiitsss
ppptiiiitsss
ppptiiiitsss
tttttiiitttt
mmmmtttttiii
mmmmtpptiiii
mmmmtpptiiii
mmmtttttiiii
ttttmmmttttt
kkktmmmmtppp
kkktmmmmtppp
kkktmmmmtppp`;
---

<div class="mosaiq-logo">
    {
        logo.split('\n').map((row, y) => (
            <div class="row">
                {row.split('').map((char, x) => {
                    const color = colors[char as keyof typeof colors] || colors.t;
                    return (
                        <div
                            class={color === "transparent" ? "cell-spacer" : "cell"}
                            style={`background-color: ${color};`}
                        />
                    );
                })}
            </div>
        ))
    }
</div>
<script>
    import { gsap } from 'gsap';

    import { ScrollTrigger } from 'gsap/ScrollTrigger';
    import { ScrollSmoother } from 'gsap/ScrollSmoother';

    gsap.registerPlugin(ScrollTrigger, ScrollSmoother);
    const content = document.querySelector('.mosaiq-logo');
    if (!content) throw new Error('No content element found');

    const cells = content.querySelectorAll('.cell');

    // Store paths globally so they don't get recalculated
    let globalPaths: Map<Element, Array<{ start: { x: number; y: number }; end: { x: number; y: number } }>> | null = null;

    function calculatePaths() {
        if (globalPaths) return globalPaths;

        const projectCards = document.querySelectorAll('.project-card');
        
        const paths = new Map<Element, Array<{ start: { x: number; y: number }; end: { x: number; y: number } }>>();
        
        cells.forEach((cell, index) => {
            const cellRect = cell.getBoundingClientRect();
            const cellCenter = {
                x: cellRect.left + cellRect.width / 2,
                y: cellRect.top + cellRect.height / 2
            };
            
            const cellPaths: Array<{ start: { x: number; y: number }; end: { x: number; y: number } }> = [];
            
            projectCards.forEach((card) => {
                const cardRect = card.getBoundingClientRect();
                const cardCenter = {
                    x: cardRect.left + cardRect.width / 2,
                    y: cardRect.top + cardRect.height / 2
                };

                // calculate normal-distributed random offset for path
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                const z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2);
                const offsetX = z0 * 50;
                const offsetY = z1 * 50;

                const offsetCardCenter = {
                    x: cardCenter.x + offsetX,
                    y: cardCenter.y + offsetY
                };
                
                cellPaths.push({
                    start: cellCenter,
                    end: offsetCardCenter,
                });
            });
            
            paths.set(cell, cellPaths);
        });
        
        return paths;
    }

    // Store timelines to avoid recreating them
    const cellTimelines = new Map<Element, gsap.core.Timeline>();

    // Function to animate a cell along a path
    function createScrollControlledAnimation(cell) {
        // Don't recreate if timeline already exists
        if (cellTimelines.has(cell)) {
            return cellTimelines.get(cell)!;
        }

        const paths = calculatePaths();
        const cellPaths = paths.get(cell);

        const duration = 2 + Math.random() * 0.5; // Random duration between 2 and 5 seconds
        const rotation = Math.random() * 180 - 90; // Random rotation angle

        // Create a timeline for the animation
        const tl = gsap.timeline({ paused: true});
        
        if (!cellPaths) return tl;

        for (let i = 0; i < cellPaths.length; i++) {
            const path = cellPaths[i];
            const logoRect = content!.getBoundingClientRect();
            
            // Convert screen coordinates to logo coordinates
            const startX = path.start.x - logoRect.left;
            const startY = path.start.y - logoRect.top;
            const endX = path.end.x - logoRect.left;
            const endY = path.end.y - logoRect.top;

            let distance: number;
            if (i === 0) {
                distance = Math.hypot(endX - startX, endY - startY);
            } else {
                const prevPath = cellPaths[i - 1];
                const prevEndX = prevPath.end.x - logoRect.left;
                const prevEndY = prevPath.end.y - logoRect.top;
                distance = Math.hypot(endX - prevEndX, endY - prevEndY);
            }
            
            tl.to(cell, {
                x: endX - startX,
                y: endY - startY,
                // outline: '4px solid var(--color-background)',
                rotation,
                duration: distance, // Scale duration based on distance
                ease: 'linear'
            });
        }
    
        return tl;
    }

    let scrollTriggersCreated = false;

    function createScrollTriggers() {
        if (scrollTriggersCreated) return;
        
        cells.forEach(cell => {
            const tl = createScrollControlledAnimation(cell);
            
            ScrollTrigger.create({
                trigger: document.body,
                start: "100px top",
                end: "bottom bottom",
                scrub: 1,
                onUpdate: (self) => {
                    tl.progress(self.progress);
                }
            });
        });
        
        scrollTriggersCreated = true;
    }

    // Remove the refresh listener since we don't want to recreate
    // ScrollTrigger.addEventListener("refresh", () => { ... });

    // Create the animation when page loads
    setTimeout(() => {
        createScrollTriggers();
        ScrollTrigger.refresh();
    }, 1000);

    // gsap.to(content, {
    //     rotateX: '15deg',
    //     rotateY: '215deg',
    //     rotateZ: '45deg',
    // });

    cells.forEach((cell, index) => {
        gsap.fromTo(
            cell,
            { opacity: 0, y: 50 },
            {
                opacity: 1,
                y: 0,
                delay: index * 0.01,
                duration: 0.5,
                ease: 'power2.out',
            }
        );

        // gsap.fromTo(
        //     cell,
        //     { rotateX: '0deg', rotateY: '0deg' },
        //     {
        //         rotateX: `${Math.random() * 45}deg`,
        //         rotateY: `${Math.random() * 45}deg`,
        //         duration: Math.random() * 2 + 1,
        //         ease: 'none',
        //         repeat: -1,
        //         yoyo: true,
        //     }
        // );

        // cell.addEventListener('mouseenter', () => {
        //     gsap.to(cell, {
        //         duration: 0.3,
        //         ease: 'power2.out',
        //     });
        // });
        // cell.addEventListener('mouseleave', () => {
        //     gsap.to(cell, {
        //         duration: 3.3,
        //         ease: 'power2.out',
        //     });
        // });
    });
</script>
<style>
    .mosaiq-logo {
        display: flex;
        gap: 0;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }
    .row {
        display: flex;
        gap: 0;
    }
    .cell, .cell-spacer {
        width: 50px;
        height: 50px;
        z-index: 2;
    }
</style>
